<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <title>井字棋"段位"挑战</title>
    <style>
      body {
        font-family: "Arial", sans-serif;
        background: linear-gradient(to bottom right, #f0f4f8, #d9e2ec);
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        margin: 0;
        color: #4a5568;
      }

      .game-container {
        text-align: center;
        background-color: white;
        border-radius: 12px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        padding: 30px;
        width: 500px;
      }

      h1 {
        color: #2b3e50;
        margin-bottom: 15px;
        font-size: 2.2em;
      }

      .controls {
        margin-bottom: 15px;
      }

      .difficulty-selector {
        margin-bottom: 10px;
      }

      .difficulty-selector label {
        display: inline-block;
        width: 80px;
        text-align: left;
      }

      .status {
        font-size: 1.4em;
        margin: 15px 0;
        min-height: 1.5em;
        font-weight: bold;
        color: #334e68;
      }

      .game-info {
        display: flex;
        justify-content: space-around;
        margin: 15px 0;
        padding: 10px;
        background-color: #f7fafc;
        border-radius: 8px;
      }

      .info-item {
        text-align: center;
      }

      .info-label {
        font-size: 0.9em;
        color: #718096;
        margin-bottom: 5px;
      }

      .info-value {
        font-size: 1.3em;
        font-weight: bold;
        color: #2b3e50;
      }

      .timer {
        font-size: 1.2em;
        color: #e53e3e;
        font-weight: bold;
        margin: 10px 0;
        min-height: 1.5em;
      }

      .timer.warning {
        color: #f56565;
        animation: pulse 1s infinite;
      }

      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
      }

      .rank-display {
        font-size: 1.8em;
        color: #4299e1;
        font-weight: bold;
        margin: 20px 0;
        padding: 15px;
        background-color: #ebf8ff;
        border-radius: 8px;
        border: 2px solid #4299e1;
      }

      .board {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        grid-gap: 10px;
        margin: 20px auto;
        max-width: 300px;
      }

      .cell {
        width: 90px;
        height: 90px;
        background-color: #edf2f7;
        border-radius: 8px;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 2.5em;
        font-weight: bold;
        cursor: pointer;
        transition: background-color 0.3s;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
      }

      .cell.disabled {
        cursor: not-allowed;
        opacity: 0.6;
      }

      .cell:hover {
        background-color: #e2e8f0;
      }

      .cell.x {
        color: #e53e3e; /* 红色 */
      }

      .cell.o {
        color: #3182ce; /* 蓝色 */
      }

      button {
        background-color: #4299e1;
        color: white;
        border: none;
        padding: 12px 24px;
        font-size: 1.1em;
        border-radius: 6px;
        cursor: pointer;
        margin-top: 10px;
        transition: background-color 0.3s;
      }

      button:hover {
        background-color: #3182ce;
      }

      .thinking {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .questions-section {
        margin-top: 30px;
        padding: 20px;
        background-color: #f7fafc;
        border-radius: 8px;
        text-align: left;
      }

      .questions-section h3 {
        color: #2b3e50;
        margin-bottom: 15px;
        border-bottom: 2px solid #4299e1;
        padding-bottom: 5px;
      }

      .question {
        margin-bottom: 20px;
      }

      .question p {
        font-weight: bold;
        color: #4a5568;
        margin-bottom: 8px;
      }

      .answer-box {
        width: 100%;
        min-height: 60px;
        padding: 10px;
        border: 1px solid #cbd5e0;
        border-radius: 4px;
        font-family: inherit;
        font-size: 0.95em;
        resize: vertical;
        box-sizing: border-box;
      }

      .answer-box:focus {
        outline: none;
        border-color: #4299e1;
        box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.2);
      }

      #submit-answers {
        width: 100%;
        margin-top: 15px;
      }

      #submit-status {
        text-align: center;
        min-height: 1.5em;
      }

      #submit-status.success {
        color: #38a169;
      }

      #submit-status.error {
        color: #e53e3e;
      }
    </style>
  </head>
  <body>
    <div class="game-container">
      <h1>井字棋"段位"挑战</h1>
      <div class="game-info">
        <div class="info-item">
          <div class="info-label">当前难度</div>
          <div class="info-value" id="current-difficulty">0</div>
        </div>
        <div class="info-item">
          <div class="info-label">剩余机会</div>
          <div class="info-value" id="remaining-chances">3</div>
        </div>
      </div>
      <div class="status" id="status">您的回合</div>
      <div class="timer" id="timer"></div>
      <div
        class="status"
        id="thinking-time"
        style="font-size: 1em; min-height: 1.2em"
      ></div>
      <div class="rank-display" id="rank-display" style="display: none;"></div>
      <div class="board" id="board">
        <div class="cell" data-index="0"></div>
        <div class="cell" data-index="1"></div>
        <div class="cell" data-index="2"></div>
        <div class="cell" data-index="3"></div>
        <div class="cell" data-index="4"></div>
        <div class="cell" data-index="5"></div>
        <div class="cell" data-index="6"></div>
        <div class="cell" data-index="7"></div>
        <div class="cell" data-index="8"></div>
      </div>
      <button id="restart">重新开始</button>
      <button id="next-challenge" style="display: none;">下一局挑战</button>

      <!-- 新增的问题回答区域 -->
      <div class="questions-section" id="questions-section" style="display: none;">
        <h3>课堂思考问题</h3>

        <div class="question">
          <p>1. 从难度0到难度5，AI下棋时的思考时间有什么变化？</p>
          <textarea
            class="answer-box"
            id="answer-1"
            placeholder="请在此写下你的观察..."
          ></textarea>
        </div>

        <div class="question">
          <p>2. 你觉得不同难度的AI，在下棋特点上有什么变化？</p>
          <textarea
            class="answer-box"
            id="answer-2"
            placeholder="请在此写下你的发现..."
          ></textarea>
        </div>

        <div class="question">
          <p>
            3.
            你觉得AI在下棋时是如何思考的？是靠背棋谱？还是和我们一样依靠感觉和经验？抑或是有其他的办法？给出你的猜测。
          </p>
          <textarea
            class="answer-box"
            id="answer-3"
            placeholder="请在此写下你的猜想..."
          ></textarea>
        </div>
        
        <button id="submit-answers" style="margin-top: 15px;">提交答案</button>
        <div id="submit-status" style="margin-top: 10px; color: #4299e1; font-weight: bold;"></div>
      </div>
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const boardElement = document.getElementById("board");
        const statusElement = document.getElementById("status");
        const restartButton = document.getElementById("restart");
        const nextChallengeButton = document.getElementById("next-challenge");
        const currentDifficultyElement = document.getElementById("current-difficulty");
        const remainingChancesElement = document.getElementById("remaining-chances");
        const timerElement = document.getElementById("timer");
        const rankDisplayElement = document.getElementById("rank-display");

        let board = ["", "", "", "", "", "", "", "", ""];
        let currentPlayer = "X"; // X is human, O is AI
        let gameActive = true;
        let aiThinking = false;
        let currentDifficulty = 0;
        let remainingChances = 3;
        let timerInterval = null;
        let timeLeft = 30;

        const winningConditions = [
          [0, 1, 2],
          [3, 4, 5],
          [6, 7, 8], // 行
          [0, 3, 6],
          [1, 4, 7],
          [2, 5, 8], // 列
          [0, 4, 8],
          [2, 4, 6], // 对角线
        ];

        function startTimer() {
          clearTimer();
          timeLeft = 30;
          updateTimerDisplay();
          timerInterval = setInterval(() => {
            timeLeft--;
            updateTimerDisplay();
            if (timeLeft <= 0) {
              clearTimer();
              // 时间到，自动判输
              statusElement.textContent = "时间到！您输了！";
              gameActive = false;
              disableAllCells();
              handleGameLoss();
            }
          }, 1000);
        }

        function clearTimer() {
          if (timerInterval) {
            clearInterval(timerInterval);
            timerInterval = null;
          }
        }

        function updateTimerDisplay() {
          if (timeLeft <= 10) {
            timerElement.textContent = `倒计时: ${timeLeft} 秒`;
            timerElement.classList.add("warning");
          } else {
            timerElement.textContent = `倒计时: ${timeLeft} 秒`;
            timerElement.classList.remove("warning");
          }
        }

        function handleCellClick(e) {
          if (!gameActive || currentPlayer !== "X" || aiThinking) return;

          const cell = e.target;
          const index = parseInt(cell.getAttribute("data-index"));

          if (board[index] !== "") return;

          // 立即绘制玩家棋子
          makeMove(index, "X");
          clearTimer(); // 清除倒计时

          // 检查游戏是否因玩家落子而结束
          if (checkGameEnd()) return;

          // AI回合
          currentPlayer = "O";
          statusElement.textContent = "AI 思考中...";
          aiThinking = true;

          // 添加这一行来获取显示思考时间的元素
          const thinkingTimeElement = document.getElementById("thinking-time");
          thinkingTimeElement.textContent = ""; // 清空之前的内容

          // 记录开始时间
          const startTime = Date.now();

          // 启动定时器来更新显示的思考时间
          const timer = setInterval(() => {
            const elapsed = ((Date.now() - startTime) / 1000).toFixed(3);
            thinkingTimeElement.textContent = `AI 思考时间: ${elapsed} 秒`;
          }, 100); // 每100毫秒更新一次

          // 使用setTimeout让UI有机会更新，然后执行AI思考
          // 使用 requestAnimationFrame 确保在下一帧执行，让UI先更新
          requestAnimationFrame(() => {
            setTimeout(() => {
              aiMove();
              aiThinking = false;
              // 停止计时器并显示最终时间
              clearInterval(timer);
              const elapsed = ((Date.now() - startTime) / 1000).toFixed(3);
              thinkingTimeElement.textContent = `AI 思考时间: ${elapsed} 秒`;
              
              // AI下完后，如果是玩家回合，启动倒计时
              if (currentPlayer === "X" && gameActive) {
                startTimer();
              }
            }, 10);
          });
        }

        function makeMove(index, player) {
          board[index] = player;
          const cell = document.querySelector(`[data-index="${index}"]`);
          cell.textContent = player;
          cell.classList.add(player.toLowerCase());
        }

        function simulateComputation(depth) {
          // 大幅增加计算负载，让差异更明显
          // 使用指数增长来模拟组合爆炸，但限制最大迭代次数以避免浏览器长时间卡死
          const maxIterations = 50000000; // 限制最大迭代次数（约5秒的计算量）
          const iterations = Math.min(Math.pow(2, depth) * 2000000, maxIterations);

          let result = 0;
          for (let i = 0; i < iterations; i++) {
            result += Math.random(); // 模拟实际计算
          }
          return result;
        }

        function checkWin(currentBoard) {
          for (let condition of winningConditions) {
            const [a, b, c] = condition;
            if (
              currentBoard[a] &&
              currentBoard[a] === currentBoard[b] &&
              currentBoard[a] === currentBoard[c]
            ) {
              return currentBoard[a];
            }
          }
          return null;
        }

        function checkDraw(currentBoard) {
          return !currentBoard.includes("");
        }

        function handleGameWin() {
          clearTimer();
          statusElement.textContent = "恭喜您获胜！难度提升！";
          // 难度提升
          currentDifficulty++;
          remainingChances = 3;
          updateGameInfo();
          nextChallengeButton.style.display = "inline-block";
          restartButton.style.display = "none";
        }

        function handleGameLoss() {
          clearTimer();
          remainingChances--;
          updateGameInfo();
          
          if (remainingChances <= 0) {
            // 3次机会用完，显示段位评价
            showRank();
            nextChallengeButton.style.display = "none";
            restartButton.style.display = "none";
          } else {
            statusElement.textContent = `您输了！还有 ${remainingChances} 次机会`;
            nextChallengeButton.style.display = "inline-block";
            restartButton.style.display = "none";
          }
        }

        function showRank() {
          rankDisplayElement.style.display = "block";
          rankDisplayElement.textContent = `您的段位：${currentDifficulty} 段`;
          statusElement.textContent = "挑战结束！";
          // 显示问题区域
          const questionsSection = document.getElementById("questions-section");
          questionsSection.style.display = "block";
        }

        function updateGameInfo() {
          currentDifficultyElement.textContent = currentDifficulty;
          remainingChancesElement.textContent = remainingChances;
        }

        function checkGameEnd() {
          const winner = checkWin(board);
          if (winner) {
            clearTimer();
            if (winner === "X") {
              handleGameWin();
            } else {
              handleGameLoss();
            }
            gameActive = false;
            highlightWinningCells(winner);
            disableAllCells();
            return true;
          }
          if (checkDraw(board)) {
            clearTimer();
            // 平局算作失败
            handleGameLoss();
            gameActive = false;
            disableAllCells();
            return true;
          }
          return false;
        }

        function disableAllCells() {
          // 游戏结束时禁用所有单元格
          document.querySelectorAll(".cell").forEach((cell) => {
            cell.classList.add("disabled");
          });
        }

        function enableAllCells() {
          // 重新开始时启用所有单元格
          document.querySelectorAll(".cell").forEach((cell) => {
            cell.classList.remove("disabled");
          });
        }

        function highlightWinningCells(winner) {
          // 找到获胜组合（复用checkWin的逻辑）
          const winningCondition = findWinningCondition(winner);
          if (winningCondition) {
            const [a, b, c] = winningCondition;
            document.querySelector(
              `[data-index="${a}"]`
            ).style.backgroundColor = "#c6f6d5";
            document.querySelector(
              `[data-index="${b}"]`
            ).style.backgroundColor = "#c6f6d5";
            document.querySelector(
              `[data-index="${c}"]`
            ).style.backgroundColor = "#c6f6d5";
          }
        }

        function findWinningCondition(winner) {
          // 辅助函数：找到获胜的组合
          for (let condition of winningConditions) {
            const [a, b, c] = condition;
            if (
              board[a] === winner &&
              board[a] === board[b] &&
              board[a] === board[c]
            ) {
              return condition;
            }
          }
          return null;
        }

        function minimax(currentBoard, depth, isMaximizing, maxDepth) {
          const winner = checkWin(currentBoard);
          if (winner === "O") return 10 - depth;
          if (winner === "X") return depth - 10;
          if (checkDraw(currentBoard) || depth >= maxDepth) return 0;

          if (isMaximizing) {
            let bestScore = -Infinity;
            for (let i = 0; i < 9; i++) {
              if (currentBoard[i] === "") {
                currentBoard[i] = "O";
                const score = minimax(currentBoard, depth + 1, false, maxDepth);
                currentBoard[i] = "";
                bestScore = Math.max(score, bestScore);
              }
            }
            return bestScore;
          } else {
            let bestScore = Infinity;
            for (let i = 0; i < 9; i++) {
              if (currentBoard[i] === "") {
                currentBoard[i] = "X";
                const score = minimax(currentBoard, depth + 1, true, maxDepth);
                currentBoard[i] = "";
                bestScore = Math.min(score, bestScore);
              }
            }
            return bestScore;
          }
        }

        function aiMove() {
          if (!gameActive) return;

          // 使用当前难度
          let maxDepth = currentDifficulty;
          if (isNaN(maxDepth) || maxDepth < 0) maxDepth = 0;
          if (maxDepth > 5) maxDepth = 5;

          let bestMove = -1;
          if (maxDepth === 0) {
            // 深度为0：随机选择一个空位
            const emptyCells = [];
            for (let i = 0; i < 9; i++) {
              if (board[i] === "") {
                emptyCells.push(i);
              }
            }
            if (emptyCells.length > 0) {
              // 随机选择一个空位
              const randomIndex = Math.floor(Math.random() * emptyCells.length);
              bestMove = emptyCells[randomIndex];
            }
          } else {
            // 深度大于0：使用minimax算法前先模拟计算负载
            simulateComputation(maxDepth);

            let bestScore = -Infinity;
            let moves = [];

            // 收集所有空位
            for (let i = 0; i < 9; i++) {
              if (board[i] === "") {
                moves.push(i);
              }
            }

            // 随机打乱顺序以增加随机性（特别是在低难度时）
            shuffleArray(moves);

            // 寻找最佳移动
            for (let i of moves) {
              board[i] = "O";
              const score = minimax(board, 0, false, maxDepth);
              board[i] = "";
              if (score > bestScore) {
                bestScore = score;
                bestMove = i;
              }
            }
          }

          // 如果没有找到最佳移动（理论上不会发生），则选择第一个空位
          if (bestMove === -1) {
            for (let i = 0; i < 9; i++) {
              if (board[i] === "") {
                bestMove = i;
                break;
              }
            }
          }

          // 执行AI移动并绘制棋子
          if (bestMove !== -1) {
            makeMove(bestMove, "O");
          }

          // 检查游戏是否因AI落子而结束
          if (!checkGameEnd()) {
            currentPlayer = "X";
            statusElement.textContent = "您的回合";
            startTimer(); // 玩家回合开始倒计时
          }
        }

        // 辅助函数：随机打乱数组
        function shuffleArray(array) {
          for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
          }
        }

        function nextChallenge() {
          board = ["", "", "", "", "", "", "", "", ""];
          currentPlayer = "X";
          gameActive = true;
          aiThinking = false;
          clearTimer();

          statusElement.textContent = "您的回合";
          rankDisplayElement.style.display = "none";
          // Clear the thinking time display
          const thinkingTimeElement = document.getElementById("thinking-time");
          thinkingTimeElement.textContent = "";
          enableAllCells();
          document.querySelectorAll(".cell").forEach((cell) => {
            cell.textContent = "";
            cell.classList.remove("x", "o");
            cell.style.backgroundColor = "";
          });
          
          nextChallengeButton.style.display = "none";
          restartButton.style.display = "inline-block";
          startTimer(); // 开始倒计时
        }

        function restartGame() {
          // 重置所有游戏状态
          currentDifficulty = 0;
          remainingChances = 3;
          updateGameInfo();
          rankDisplayElement.style.display = "none";
          nextChallenge();
        }

        // 提交答案功能
        const submitAnswersButton = document.getElementById("submit-answers");
        const submitStatusElement = document.getElementById("submit-status");
        
        async function submitAnswers() {
          const answer1 = document.getElementById("answer-1").value.trim();
          const answer2 = document.getElementById("answer-2").value.trim();
          const answer3 = document.getElementById("answer-3").value.trim();
          
          if (!answer1 || !answer2 || !answer3) {
            submitStatusElement.textContent = "请完整回答所有3个问题";
            submitStatusElement.className = "error";
            return;
          }
          
          submitAnswersButton.disabled = true;
          submitStatusElement.textContent = "正在提交...";
          submitStatusElement.className = "";
          
          try {
            // 自动检测API地址（生产环境使用相对路径，开发环境使用localhost）
            const apiUrl = window.location.hostname === 'localhost' 
              ? 'http://localhost:3000/api/submit-answers'
              : '/api/submit-answers';
            const response = await fetch(apiUrl, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                rank: currentDifficulty,
                answers: {
                  question1: answer1,
                  question2: answer2,
                  question3: answer3,
                },
                timestamp: new Date().toISOString(),
              }),
            });
            
            const data = await response.json();
            
            if (response.ok) {
              submitStatusElement.textContent = "答案提交成功！";
              submitStatusElement.className = "success";
              submitAnswersButton.style.display = "none";
            } else {
              throw new Error(data.error || "提交失败");
            }
          } catch (error) {
            submitStatusElement.textContent = `提交失败：${error.message}`;
            submitStatusElement.className = "error";
            submitAnswersButton.disabled = false;
          }
        }
        
        submitAnswersButton.addEventListener("click", submitAnswers);

        // 事件监听
        boardElement.addEventListener("click", handleCellClick);
        restartButton.addEventListener("click", restartGame);
        nextChallengeButton.addEventListener("click", nextChallenge);
        
        // 初始化游戏信息显示
        updateGameInfo();
        startTimer(); // 游戏开始时启动倒计时
      });
    </script>
  </body>
</html>
